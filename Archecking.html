<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>WebXR AR Example</title>
	<style>
		#arButton {
			position: absolute;
			top: 20px;
			left: 20px;
			z-index: 1;
		}
	</style>
</head>

<body>
	<button id="arButton">Enter AR</button>
	<canvas id="xrCanvas"></canvas>


	<script src="https://cdn.jsdelivr.net/npm/hammerjs@latest/hammer.min.js"></script>

	<!-- WebXR Polyfill -->
	<script src="https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.min.js"></script>
	<!-- Your AR script -->
	<script type="importmap">
		{
			"imports": {
				"three": "./build/three.module.js",
				"three/addons/": "./jsm/"
			}
		}
	</script>

	<script type="module">

		import * as THREE from 'three';
		import { ARButton } from 'three/addons/webxr/ARButton.js';

		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

		let xrSession = null;
		let xrRefSpace = null;
		let gl = null;
		let renderer = null;
		let scene = null;
		let camera = null;
		let model = null;
		let controls = null;

		if (navigator.xr) {
			navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
				if (supported) {
					document.getElementById('arButton').style.display = 'block';
					document.getElementById('arButton').addEventListener('click', onButtonClicked);
				}
			});
		}

		function onButtonClicked() {
			navigator.xr.requestSession('immersive-ar', {
				requiredFeatures: ['local']
			}).then(onSessionStarted);
		}

		function onSessionStarted(session) {
			xrSession = session;
			xrSession.addEventListener('end', onSessionEnded);

			let canvas = document.getElementById('xrCanvas');
			gl = canvas.getContext('webgl', { xrCompatible: true });

			renderer = new THREE.WebGLRenderer({ canvas: canvas, context: gl });
			renderer.autoClear = false;

			scene = new THREE.Scene();

			//camera = new THREE.PerspectiveCamera();
			camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000);
			scene.add(camera);

			var directionalLight = new THREE.DirectionalLight(0xdddddd, 1);
			directionalLight.position.set(0, 0, 1).normalize();
			scene.add(directionalLight);

			var ambientLight = new THREE.AmbientLight(0x222222);
			scene.add(ambientLight);


			loadModel();

			controls = new OrbitControls(camera, renderer.domElement);
			//controls.addEventListener('change', render);
			controls.minDistance = 2;
			controls.maxDistance = 10;
			controls.target.set(-0.6, -0.3, -0.2);
			controls.enableDamping = true;
			controls.dampingFactor = 0.05;


			xrSession.updateRenderState({ baseLayer: new XRWebGLLayer(xrSession, gl) });

			xrSession.requestReferenceSpace('local').then((refSpace) => {
				xrRefSpace = refSpace;
				xrSession.requestAnimationFrame(onXRFrame);
			});
		}

		function onSessionEnded() {
			xrSession = null;
		}

		function onXRFrame(time, frame) {
			let session = frame.session;
			session.requestAnimationFrame(onXRFrame);

			let pose = frame.getViewerPose(xrRefSpace);
			if (pose) {
				let glLayer = session.renderState.baseLayer;

				gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				const views = pose.views;
				for (let view of views) {
					let viewport = glLayer.getViewport(view);
					renderer.setSize(viewport.width, viewport.height);
					camera.matrix.fromArray(view.transform.matrix);
					camera.projectionMatrix.fromArray(view.projectionMatrix);
					camera.updateMatrixWorld(true);
					controls.update(); // Update the controls before rendering

					renderer.render(scene, camera);
				}
			}
		}

		function loadModel() {
			const loader = new GLTFLoader();
			loader.load('3d/car.glb', function (gltf) {
				model = gltf.scene;
				model.scale.set(0.2, 0.2, 0.2); // Adjust scale as needed
				//model mirror color change
				model.traverse((child) => {
					if (child.isMesh && child.material.name === 'M4xNME_GlassClear') {
						child.material.transparent = true;
						child.material.opacity = 0.3;
						child.material.blending = THREE.NormalBlending;
					}
				});

				scene.add(model);

				// Setup Hammer.js for touch interaction
				setupHammer(renderer.domElement);
			}, undefined, function (error) {
				console.error('An error happened while loading the model:', error); // Error handling
			});
		}

		function setupHammer(element) {
			const hammer = new Hammer(element);

			// Enable panning and pinching
			hammer.get('pan').set({ direction: Hammer.DIRECTION_ALL });
			hammer.get('pinch').set({ enable: true });

			// Variables for panning
			let initialPanX = 0;
			let initialPanY = 0;

			// Variables for pinching
			let initialScale = 1;

			// Handle panning
			hammer.on('panstart', (event) => {
				initialPanX = model.rotation.y;
				initialPanY = model.rotation.x;
			});

			hammer.on('panmove', (event) => {
				model.rotation.y = initialPanX + event.deltaX * 0.005; // Adjust rotation speed
				model.rotation.x = initialPanY + event.deltaY * 0.005;
			});

			// Handle pinching
			hammer.on('pinchstart', () => {
				initialScale = model.scale.x; // Assuming uniform scaling
			});

			hammer.on('pinchmove', (event) => {
				const newScale = initialScale * event.scale;
				model.scale.set(newScale, newScale, newScale); // Apply new scale uniformly
			});
		}
	</script>
</body>

</html>
