<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WEBXR AR</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <!--<div id="app"></div>-->
    <!--<script type="module" src="./cube/normal-cube.js"></script>-->
    <!--<script type="module" src="./cube/xr-cube.js"></script>-->
    <!--<script type="module" src="./cube/xr-hit-cube.js"></script>-->
    <!--<script type="module" src="./model/xr-domOverlay.js"></script>-->

    <div id="overlay-content">
      <div id="container">
        <label for="model-select">choose model</label>
        <select id="model-select">
          <option value="option1">option1</option>
            <option value="option2">option2</option>
              <option value="option3">option3</option>
        </select>
      </div>
    </div>
	
	<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

	<script type="module">

		import * as THREE from 'three';
		import { ARButton } from 'three/addons/webxr/ARButton.js';
		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';



let loadedModels = {}
let hitTestSource = null;
let hitTestSourceRequested = false;
let overlayContent = document.getElementById('overlay-content')
let selectInput = document.getElementById('model-select')
let modelName = selectInput.value;

selectInput.addEventListener("change", (e) => {
    modelName = e.target.value
})


let gltfLoader = new GLTFLoader();
//let dracoLoader = new DRACOLoader();
//dracoLoader.setDecoderPath('/draco')
//gltfLoader.setDRACOLoader(dracoLoader)


gltfLoader.load('../webxr-ar-ajith/3d/1.glb', onLoad);
gltfLoader.load('../webxr-ar-ajith/3d/2.glb', onLoad);
gltfLoader.load('../webxr-ar-ajith/3d/3.glb', onLoad);


function onLoad(gltf) {
    console.log(gltf.scene)
    loadedModels[gltf.scene.name] = gltf.scene
   
}

console.log(loadedModels)

const scene = new THREE.Scene()

const sizes = {
    width: window.innerWidth,
    height: window.innerHeight
}

const light = new THREE.AmbientLight(0xffffff, 1.0)
scene.add(light)


let reticle = new THREE.Mesh(
    new THREE.RingGeometry(0.15, .2, 32).rotateX(-Math.PI / 2),
    new THREE.MeshStandardMaterial({ color: 0xffffff * Math.random() })
)
reticle.visible = false;
reticle.matrixAutoUpdate = false;
scene.add(reticle)

const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 1000);
camera.position.set(0, 2, 5);
camera.lookAt(new THREE.Vector3(0, 0, 0))
scene.add(camera);

const renderer = new THREE.WebGLRenderer({
    antialias: true,
    alpha: true

});

renderer.setSize(sizes.width, sizes.height);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.xr.enabled = true

document.body.appendChild(renderer.domElement);
document.body.appendChild(ARButton.createButton(renderer, {
    requiredFeatures: ['hit-test'],
    optionalFeatures: ['dom-overlay'],
    domOverlay: { root: overlayContent }
}));


let controller = renderer.xr.getController(0);
controller.addEventListener('select', onSelect);
scene.add(controller)

function onSelect() {
    if (reticle.visible) {
        let model = loadedModels[modelName].clone()
        model.position.setFromMatrixPosition(reticle.matrix);
        model.scale.set(1, 1, 1)
        scene.add(model)
    }
}

renderer.setAnimationLoop(render)

function render(timestamp, frame) {
    if (frame) {
        const referenceSpace = renderer.xr.getReferenceSpace();
        const session = renderer.xr.getSession();

        if (hitTestSourceRequested === false) {
            session.requestReferenceSpace('viewer').then(referenceSpace => {
                session.requestHitTestSource({ space: referenceSpace }).then(source =>
                    hitTestSource = source)
            })

            hitTestSourceRequested = true;

            session.addEventListener("end", () => {
                hitTestSourceRequested = false;
                hitTestSource = null;
            })
        }

        if (hitTestSource) {
            const hitTestResults = frame.getHitTestResults(hitTestSource);
            if (hitTestResults.length > 0) {
                const hit = hitTestResults[0];
                reticle.visible = true;
                reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix)

            } else {
                reticle.visible = false

            }
        }
    }

    renderer.render(scene, camera)
}

window.addEventListener('resize', () => {
    sizes.width = window.innerWidth;
    sizes.height = window.innerHeight;

    camera.aspect = sizes.width / sizes.height;
    camera.updateProjectionMatrix();

    renderer.setSize(sizes.width, sizes.height);
    renderer.setPixelRatio(window.devicePixelRatio)

})
	</script>

  </body>
</html>