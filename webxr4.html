<!doctype html>
<html>

<head>
	<meta charset="UTF-8">
	<meta name="viewport"
		content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
	<title>WebXR</title>
	<script src="https://unpkg.com/three@0.126.0/build/three.js"></script>
	<script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
</head>

<body>
	<button onclick="activateXR()">Start WebXR</button>
	<script>

		let canvas, gl, model;
		async function activateXR() {
			canvas = document.createElement("canvas");
			document.body.appendChild(canvas);
			gl = canvas.getContext("webgl", { xrCompatible: true });

			const scene = new THREE.Scene();

			const light = new THREE.AmbientLight(0xffffff, 1);
			const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
			directionalLight.position.set(10, 15, 10);
			directionalLight.castShadow = true;

			const planeGeometry = new THREE.PlaneGeometry(2000, 2000);
			planeGeometry.rotateX(-Math.PI / 2);
			const shadowMesh = new THREE.Mesh(planeGeometry, new THREE.ShadowMaterial({
				color: 0x111111,
				opacity: 0.2,
			}));
			shadowMesh.name = 'shadowMesh';
			shadowMesh.receiveShadow = true;
			shadowMesh.position.y = 10000;

			scene.add(shadowMesh);
			scene.add(light);
			scene.add(directionalLight);

			const renderer = new THREE.WebGLRenderer({
				alpha: true,
				preserveDrawingBuffer: true,
				canvas: canvas,
				context: gl
			});
			renderer.autoClear = false;

			const camera = new THREE.PerspectiveCamera();
			camera.matrixAutoUpdate = false;

			const session = await navigator.xr.requestSession("immersive-ar", { requiredFeatures: ['hit-test'] });
			session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });

			const referenceSpace = await session.requestReferenceSpace('local');
			const viewerSpace = await session.requestReferenceSpace('viewer');
			const hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

			const loader = new THREE.GLTFLoader();
			let reticle;
			loader.load("https://immersive-web.github.io/webxr-samples/media/gltf/reticle/reticle.gltf", function (gltf) {
				reticle = gltf.scene;
				reticle.visible = false;
				scene.add(reticle);
			});

			const modelPaths = [
				"3d/1.glb",
				"3d/2.glb",
				"3d/3.glb",
				"3d/4.glb"
			];

			let modelIndex = 0;

			function loadNextModel() {
				if (modelIndex >= modelPaths.length) {
					return; // no more models to load
				}
				return new Promise((resolve, reject) => {
					loader.load(modelPaths[modelIndex], function (gltf) {
						model = gltf.scene;
						model.addEventListener('touchstart', onTouchStart, false);
						model.addEventListener('touchmove', onTouchMove, false);
						model.addEventListener('touchend', onTouchEnd, false);
						resolve(model);
					}, undefined, function (error) {
						reject(error);
					});
				});
			}

			session.addEventListener("select", async () => {
				try {
					if (reticle.visible) {
						const placemodel = await loadNextModel();
						placemodel.position.copy(reticle.position);
						scene.add(placemodel);
						modelIndex++;
					}
				} catch (error) {
					console.error('Error loading model:', error);
				}
			});

			const onXRFrame = (time, frame) => {
				session.requestAnimationFrame(onXRFrame);

				gl.bindFramebuffer(gl.FRAMEBUFFER, session.renderState.baseLayer.framebuffer)

				const pose = frame.getViewerPose(referenceSpace);
				if (pose) {
					const view = pose.views[0];
					const viewport = session.renderState.baseLayer.getViewport(view);
					renderer.setSize(viewport.width, viewport.height);

					camera.matrix.fromArray(view.transform.matrix);
					camera.projectionMatrix.fromArray(view.projectionMatrix);
					camera.updateMatrixWorld(true);

					const hitTestResults = frame.getHitTestResults(hitTestSource);
					if (hitTestResults.length > 0 && reticle) {
						const hitPose = hitTestResults[0].getPose(referenceSpace);
						reticle.visible = true;
						reticle.position.set(
							hitPose.transform.position.x,
							hitPose.transform.position.y,
							hitPose.transform.position.z
						);
						reticle.updateMatrixWorld(true);
					} else if (reticle) {
						reticle.visible = false;
					}

					renderer.render(scene, camera);
				}
			};

			session.requestAnimationFrame(onXRFrame);
		}


		let offsetX = 0, offsetY = 0;

		function onTouchStart(event) {
			event.preventDefault();
			const touches = event.touches;
			if (touches.length === 1) { // Single touch
				selectedModel = event.target;
				const rect = selectedModel.getBoundingClientRect();
				offsetX = touches[0].clientX - rect.left;
				offsetY = touches[0].clientY - rect.top;
				console.log(`Touch started on model ${selectedModel.name}`);
			} else if (touches.length === 2) { // Two-finger touch
				// Add logic for gestures like pinch-to-zoom or rotate
			}
		}

		function onTouchMove(event) {
			event.preventDefault();
			if (selectedModel) {
				const touches = event.touches;
				if (touches.length === 1) { // Single touch
					selectedModel.position.x = touches[0].clientX - offsetX;
					selectedModel.position.z = touches[0].clientY - offsetY;
					selectedModel.updateMatrixWorld(true);
					console.log(`Touch moved on model ${selectedModel.name}`);
				} else if (touches.length === 2) { // Two-finger touch
					// Add logic for gestures like pinch-to-zoom or rotate
				}
			}
		}

		function onTouchEnd(event) {
			event.preventDefault();
			if (selectedModel) {
				console.log(`Touch ended on model ${selectedModel.name}`);
				selectedModel = null;
			}
		}
	</script>
</body>

</html>
