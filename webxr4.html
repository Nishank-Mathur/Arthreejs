<!doctype html>
<html>

<head>
	<meta charset="UTF-8">
	<meta name="viewport"
		content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
	<title>WebXR</title>
	<script src="https://unpkg.com/three@0.126.0/build/three.js"></script>
	<script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
</head>

<body>
	<button onclick="activateXR()">Start WebXR</button>
	<script>
		async function activateXR() {
			const canvas = document.createElement("canvas");
			document.body.appendChild(canvas);
			const gl = canvas.getContext("webgl", { xrCompatible: true });

			canvas.addEventListener('touchstart', onTouchStart, false);
			canvas.addEventListener('touchmove', onTouchMove, false);
			canvas.addEventListener('touchend', onTouchEnd, false);

			const scene = new THREE.Scene();

			const light = new THREE.AmbientLight(0xffffff, 1);
			const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
			directionalLight.position.set(10, 15, 10);
			directionalLight.castShadow = true;

			const planeGeometry = new THREE.PlaneGeometry(2000, 2000);
			planeGeometry.rotateX(-Math.PI / 2);
			const shadowMesh = new THREE.Mesh(planeGeometry, new THREE.ShadowMaterial({
				color: 0x111111,
				opacity: 0.2,
			}));
			shadowMesh.name = 'shadowMesh';
			shadowMesh.receiveShadow = true;
			shadowMesh.position.y = 10000;

			scene.add(shadowMesh);
			scene.add(light);
			scene.add(directionalLight);

			const renderer = new THREE.WebGLRenderer({
				alpha: true,
				preserveDrawingBuffer: true,
				canvas: canvas,
				context: gl
			});
			renderer.autoClear = false;

			const camera = new THREE.PerspectiveCamera();
			camera.matrixAutoUpdate = false;

			const session = await navigator.xr.requestSession("immersive-ar", { requiredFeatures: ['hit-test'] });
			session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });

			const referenceSpace = await session.requestReferenceSpace('local');
			const viewerSpace = await session.requestReferenceSpace('viewer');
			const hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

			const loader = new THREE.GLTFLoader();
			let reticle;
			loader.load("https://immersive-web.github.io/webxr-samples/media/gltf/reticle/reticle.gltf", function (gltf) {
				reticle = gltf.scene;
				reticle.visible = false;
				scene.add(reticle);
			});

			const modelPaths = [
				"3d/1.glb",
				"3d/2.glb",
				"3d/3.glb",
				"3d/4.glb"
			];

			let modelIndex = 0;

			function loadNextModel() {
				return new Promise((resolve, reject) => {
					loader.load(modelPaths[modelIndex], function (gltf) {
						const model = gltf.scene;
						resolve(model);
					}, undefined, function (error) {
						reject(error);
					});
				});
			}

			session.addEventListener("select", async () => {
				try {
					if (reticle.visible) {
						const model = await loadNextModel();
						model.position.copy(reticle.position);
						scene.add(model);
						modelIndex = (modelIndex + 1) % modelPaths.length;
					}
				} catch (error) {
					console.error('Error loading model:', error);
				}
			});

			const onXRFrame = (time, frame) => {
				session.requestAnimationFrame(onXRFrame);

				gl.bindFramebuffer(gl.FRAMEBUFFER, session.renderState.baseLayer.framebuffer)

				const pose = frame.getViewerPose(referenceSpace);
				if (pose) {
					const view = pose.views[0];
					const viewport = session.renderState.baseLayer.getViewport(view);
					renderer.setSize(viewport.width, viewport.height);

					camera.matrix.fromArray(view.transform.matrix);
					camera.projectionMatrix.fromArray(view.projectionMatrix);
					camera.updateMatrixWorld(true);

					const hitTestResults = frame.getHitTestResults(hitTestSource);
					if (hitTestResults.length > 0 && reticle) {
						const hitPose = hitTestResults[0].getPose(referenceSpace);
						reticle.visible = true;
						reticle.position.set(
							hitPose.transform.position.x,
							hitPose.transform.position.y,
							hitPose.transform.position.z
						);
						reticle.updateMatrixWorld(true);
					} else if (reticle) {
						reticle.visible = false;
					}

					renderer.render(scene, camera);
				}
			};

			session.requestAnimationFrame(onXRFrame);
		}

		let isTouching = false;

		function onTouchStart(event) {
			event.preventDefault();
			isTouching = true;
			const touch = event.touches[0];
			const x = touch.clientX;
			const y = touch.clientY;

			console.log(`Touch started at (${x}, ${y})`);
			// Add logic to place a model or initiate an action
		}

		function onTouchMove(event) {
			event.preventDefault();
			if (isTouching) {
				const touch = event.touches[0];
				const x = touch.clientX;
				const y = touch.clientY;

				console.log(`Touch moved to (${x}, ${y})`);
				// Add logic to move an object or handle gestures
			}
		}

		function onTouchEnd(event) {
			event.preventDefault();
			isTouching = false;
			console.log("Touch ended");
			// Add logic to finalize placing or interacting with an object
		}
	</script>
</body>

</html>