<!doctype html>
<html>

<head>
	<meta charset="UTF-8">
	<meta name="viewport"
		content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
	<title>WebXR</title>
	<script src="https://unpkg.com/three@0.126.0/build/three.js"></script>
	<script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
	<script src="https://unpkg.com/three@0.126.0/examples/js/controls/OrbitControls.js"></script>
</head>

<body>
	<button onclick="activateXR()">Start AR</button>
	<script>
		let scene, renderer, camera, model, controls;
		let canvas, gl;
		async function activateXR() {
			canvas = document.createElement("canvas");
			document.body.appendChild(canvas);
			gl = canvas.getContext("webgl", { xrCompatible: true });

			scene = new THREE.Scene();

			const light = new THREE.AmbientLight(0xffffff, 1);
			const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
			directionalLight.position.set(10, 15, 10);
			directionalLight.castShadow = true;

			const planeGeometry = new THREE.PlaneGeometry(2000, 2000);
			planeGeometry.rotateX(-Math.PI / 2);
			const shadowMesh = new THREE.Mesh(planeGeometry, new THREE.ShadowMaterial({
				color: 0x111111,
				opacity: 0.2,
			}));
			shadowMesh.name = 'shadowMesh';
			shadowMesh.receiveShadow = true;
			shadowMesh.position.y = 10000;

			scene.add(shadowMesh);
			scene.add(light);
			scene.add(directionalLight);

			renderer = new THREE.WebGLRenderer({
				antialias: true,
				alpha: true,
				preserveDrawingBuffer: true,
				canvas: canvas,
				context: gl
			});
			renderer.autoClear = false;

			renderer.setSize(canvas.clientWidth, canvas.clientHeight);

			document.body.appendChild(renderer.domElement);


			camera = new THREE.PerspectiveCamera();
			camera.matrixAutoUpdate = false;

			// Initialize OrbitControls
			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.target.set(0, 0, 0); // Set the center of orbit
			controls.update();

			const session = await navigator.xr.requestSession("immersive-ar", { requiredFeatures: ['hit-test'] });
			session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });

			const referenceSpace = await session.requestReferenceSpace('local');
			const viewerSpace = await session.requestReferenceSpace('viewer');
			const hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

			const loader = new THREE.GLTFLoader();
			let reticle;
			loader.load("https://immersive-web.github.io/webxr-samples/media/gltf/reticle/reticle.gltf", function (gltf) {
				reticle = gltf.scene;
				reticle.visible = false;
				scene.add(reticle);
			});

			const modelPaths = [
				"3d/1.glb",
				"3d/2.glb",
				"3d/3.glb",
				"3d/4.glb"
			];

			let modelIndex = 0;

			function loadNextModel() {
				if (modelIndex >= modelPaths.length) {
					return; // no more models to load
				}
				return new Promise((resolve, reject) => {
					loader.load(modelPaths[modelIndex], function (gltf) {
						model = gltf.scene;
						resolve(model);
					}, undefined, function (error) {
						reject(error);
					});
				});
			}

			session.addEventListener("select", async () => {
				try {
					if (reticle.visible) {
						const modelplace = await loadNextModel();
						modelplace.position.copy(reticle.position);
						scene.add(modelplace);
						modelIndex++;
					}
				} catch (error) {
					console.error('Error loading model:', error);
				}
				alert('touch start');
			});

			const onXRFrame = (time, frame) => {
				session.requestAnimationFrame(onXRFrame);

				gl.bindFramebuffer(gl.FRAMEBUFFER, session.renderState.baseLayer.framebuffer)

				const pose = frame.getViewerPose(referenceSpace);
				if (pose) {
					const view = pose.views[0];
					const viewport = session.renderState.baseLayer.getViewport(view);
					renderer.setSize(viewport.width, viewport.height);

					camera.matrix.fromArray(view.transform.matrix);
					camera.projectionMatrix.fromArray(view.projectionMatrix);
					camera.updateMatrixWorld(true);

					controls.update(); // Update OrbitControls

					const hitTestResults = frame.getHitTestResults(hitTestSource);
					if (hitTestResults.length > 0 && reticle) {
						const hitPose = hitTestResults[0].getPose(referenceSpace);
						reticle.visible = true;
						reticle.position.set(
							hitPose.transform.position.x,
							hitPose.transform.position.y,
							hitPose.transform.position.z
						);
						reticle.updateMatrixWorld(true);
					} else if (reticle) {
						reticle.visible = false;
					}

					renderer.render(scene, camera);
				}
			};

			renderer.domElement.addEventListener('touchstart', function (e) {
				e.preventDefault();
				e.stopPropagation();
				alert('touch start');
			}, { passive: false });

			session.requestAnimationFrame(onXRFrame);
		}


	</script>
</body>

</html>